#!/usr/bin/env bun

import path from "node:path";
import fs from "node:fs";

import Bun from "bun";
import esbuild from "esbuild";
import chalk from "chalk";

import { transpile } from "src/transpiler";

import pkg from "../package.json" with { type: "json" };

const PORT = 3000;
const ROOT = process.cwd();

const PLUGINS = [
  {
    name: "jsx-transpiler",
    setup(build) {
      build.onLoad({ filter: /\.jsx$/ }, async (arg) => {
        const jsx = await Bun.file(arg.path).text();
        const contents = transpile(jsx);
        return {
          contents,
          loader: "jsx",
        };
      });
      build.onResolve({ filter: /.*/ }, (arg) => {
        if (arg.path === pkg.name) {
          return {
            path: path.join(import.meta.dir, "../src/index.js"),
            namespace: "file",
          };
        }
      });
    },
  },
];

const build = async () => {
  const index = await Bun.file(`${ROOT}/index.html`).text();
  const source = index.match(/script src=['"](.*\.jsx)['"]/)[1];

  await esbuild.build({
    entryPoints: [`${ROOT}/${source}`],
    outdir: `${ROOT}/dist`,
    bundle: true,
    minify: true,
    plugins: PLUGINS,
  });

  await Bun.write(
    `${ROOT}/dist/index.html`,
    index.replace(source, path.basename(source).replace(".jsx", ".js")),
  );

  await Bun.write(`${ROOT}/dist/sw.js`, "function SW() {}");
};

const dev = () => {
  const handler = async (req) => {
    const url = new URL(req.url);
    const file = url.pathname.replaceAll("..", "");

    if (file === "/sw.js") {
      const content = "function SW() {}";
      return new Response(content, {
        headers: { "Content-Type": "application/javascript" },
      });
    }

    if (file.endsWith(".js") || file.endsWith(".jsx")) {
      try {
        const entryPoint = path.resolve(ROOT, url.pathname.slice(1));
        const result = await esbuild.build({
          entryPoints: [entryPoint],
          bundle: true,
          write: false,
          plugins: PLUGINS,
        });
        if (result.outputFiles?.length) {
          const content = result.outputFiles[0].text;
          // console.log(entryPoint, content);
          return new Response(content, {
            headers: { "Content-Type": "application/javascript" },
          });
        }
      } catch (error) {
        console.error(`Error serving file ${file}:`, error);
        return new Response("Error processing file", { status: 500 });
      }
    }

    if (file !== "/" && fs.existsSync(file)) {
      const content = await Bun.file(file).bytes();
      return new Response(content, {
        status: 200,
        headers: { "Content-Type": getContentType(file) },
      });
    }

    const content = await Bun.file(path.join(ROOT, "index.html")).text();
    return new Response(content, {
      headers: { "Content-Type": "text/html" },
    });
  };

  const getContentType = (file) => {
    if (file.endsWith(".html")) return "text/html";
    if (file.endsWith(".css")) return "text/css";
    if (file.endsWith(".js")) return "application/javascript";
    return "application/octet-stream";
  };

  const server = Bun.serve({
    port: PORT,
    fetch: handler,
  });

  console.log(`
  ${chalk.cyan(pkg.name.replace(/^./, (m) => m.toUpperCase()))} ${chalk.green(`v${pkg.version}`)} ${chalk.gray("- DEV")}
  ${chalk.gray("at")} http://localhost:${server.port}/
`);

  process.once("SIGINT", () => server.stop());
  process.once("SIGTERM", () => server.stop());
};

const preview = () => {
  const server = Bun.serve({
    port: PORT,
    async fetch(req) {
      const url = new URL(req.url);
      const file = url.pathname.replaceAll("..", "");
      return new Response(
        Bun.file(`${ROOT}/dist${file === "/" ? "/index.html" : file}`),
      );
    },
    error() {
      return new Response(null, { status: 404 });
    },
  });

  console.log(`
    ${chalk.cyan(pkg.name.replace(/^./, (m) => m.toUpperCase()))} ${chalk.green(`v${pkg.version}`)} ${chalk.gray("- PREVIEW")}
    ${chalk.gray("at")} http://localhost:${server.port}/
  `);

  process.once("SIGINT", () => server.stop());
  process.once("SIGTERM", () => server.stop());
};

const index = Bun.argv.indexOf(import.meta.filename);
const [cmd, ...args] = Bun.argv.slice(index + 1);

switch (cmd || "dev") {
  case "build":
    build(...args);
    break;
  case "dev":
    dev(...args);
    break;
  case "preview":
    preview(...args);
    break;
  default:
    console.log(`Unknown command: ${cmd}`);
}
